\chapter{Introduction}\label{chapter:intro}

When thinking about truth value of a sentence such as "I am sad", we have to put it in a context. Am I sad now? In general? Or maybe just sometimes? This context -- "now", "in general", "sometimes" -- can be thought of as a form of truth qualification: "I am always sad", for instance, might lead us to believe that in this particular moment, I am sad as well. The reverse is usually not true -- just because I am sad right now, does not make me sad every single day. We can think of "in general", "right now" and other qualifiers as \emph{modals}.

Statements of logic can be qualified in a similar manner: for a logic to be considered modal it has to qualify the truth. Alethic modalities talk about possibility, necessity and impossibility; epistemic logics treat knowledge and belief as qualifiers; deontic modalities use obligation and permission. Such qualifications are not a new concept --  modal logic as a discipline of philosophy dates back to ancient Greece~\cite{sep-modality-medieval}, to the works of Aristotle with later developments of Diodorus Cronus, Philo the Dialectician and Chrysippus. They were considering, among other, the problem of future contingents -- that is, whether one can meaningfully regard future contingents as true or false now, given that the future is still open and undecided. This lead to developments in both modal and temporal logic.

Modality in philosophy was for many years controversial, not widely used and far from a formal discipline. It wasn't until C. I. Lewis's series of articles and finally his book "Symbolic Logic" from 1932, that modern modal logic was born~\cite{sep-logic-modal-origins}. Lewis introduced five modal systems, \logicSone{} through \logicSfive{}, last two of which are examples of what we now consider \emph{normal modal systems}. His approach was to change the definition of implication -- making it more in line with its natural interpretation, that one proposition implies the other if the second can be deduced logically from the first. In particular, in Lewis's opinion it should not be the case that $ p ---> ( q ---> p) $. Using possibility ($<*>$) as a modal primitive allowed him to redefine implication as $p --->q := \neg <*>(p \wedge \neg q)$. He did not yet think of modality as we tend to do nowadays -- there was no separation of possibility from propositional rules, as is the case in almost all current formalizations. While we tend to interpret modality as something additional, with its own set of rules, Lewis saw it as embedded in all the definitions and inseparable. Even though his approach did not last, systems he introduced -- in particular \logicSfour{} and \clogic{} -- are still subjects of active research.

Just as C.I. Lewis is considered the father of the syntactic tradition, Saul Kripke is the father of modal semantics. In his 1959 article~\cite{kripke59}  he introduced what is now referred to as \emph{Kripke semantics} or possible worlds semantics, a formal semantics for non-classical logic systems. This allowed modal logics to further develop as a field of formal reasoning.\\

Even before the formal semantics for modalities were developed, another important concept was introduced by Fitch~\cite{fitch52}: intuitionistic modal logic -- first defined as modal logic \logicT{} extended with formula ${\forall x, [*]F x ---> [*] \forall x, F x}$ (known as the Barcan formula), with formalization given as both Hilbert-style axiomatization and Gentzen-style sequent calculus. It was not very influential, not nearly as much as the subsequent work in this field by Prior in his "Time and Modality"~\cite{prior55}, where \mipq{} logic -- now known as \logic{} -- was defined. Another milestone was a PhD thesis of Alex K. Simpson~\cite{simpson}, where he analyses proof theory and semantics for a family of intuitionistic modal logics. Simpson's natural deduction systems based on geometric theories were further developed to better reflect the interpretations given to various modal logics, for example by Pfenning and Davies~\cite{stagedcomp} or Galmiche and Sahli~\cite{labelfree}.\\

Another concept crucial for this thesis is a correspondence between computer programs and formal proofs known as Curry-Howard isomorphism. It was first observed by Curry in 1934 that axioms of simple intuitionistic implication logic can be viewed as types for combinators. In 1958 Curry extended this observation by noticing that Hilbert-style deduction systems and a fragment of combinatory logic, used as a standard model of computation, are one and the same thing. Finally, in 1969 Howard made the discovery that natural deduction intuitionistic proofs can be interpreted as typed lambda calculus. The relation between programs and proofs did not stop there -- increasingly complicated formal systems were being developed, giving birth to the field of modern type theory. 

One particularly interesting calculus that uses higher-order logic, created within this trend is Calculus of Constructions~\cite{coq_coc} -- a basis for the Coq automatic prover, where proving theorems means writing programs. An example of Coq is particularly important to us as we use it for the formalizations of \logic{} logic presented in this thesis. That being said, there were of course other languages developed based on this concept, including ones that gave intuitionistic modal logics meaning as programming languages.

One example of such language is ML5~\cite{ml5}, a language developed by Tom Murphy VII et al. as part of the ConCert platform. It is a programming language based on ML with support for parallel computations. The base for its type system is exactly the logic that is of interest to us -- \logic{}.  Another variant of \logic{} formalization, this time without language accompanying the logic, came from Galmiche and Salhi's article~\cite{labelfree} where they gave an alternative decidability result for intuitionistic \logicSfive{}. These two papers form a base for this thesis. They present different approaches, as Galmiche and Salhi do not use labels for their formalism, resulting in syntactically pure logic, whereas Tom Murphy et al. name contexts, thus extending the usual syntax with labels.

\section{Goals and approach}
The natural deduction system that formed the base for Murphy's ML5 was formalized in Twelf~\cite{labeled}, but most articles on modal logics lack verifiable implementations in a theorem prover. In particular an alternative natural deduction system using multi-contextual environment~\cite{labelfree} does not have a formal implementation. One of our goals is therefore filling that gap using Coq.\\

As our interest lies more in theoretical results of variants of \logic{}, rather than practical implementations, we have chosen Lambda 5 with its simple external language~\cite{labeled}, rather than full system with configuration, networks and tables. We provide an alternative (Coq, rather than Twelf) implementation of Lambda 5, but also, using similar syntax, extend Galmiche's natural deduction for \lang{} with terms. As the resulting language does not use labels to express changing worlds, we also propose a new variant of this system that uses labels for worlds, but is otherwise very similar to label-free version of \logic{}, in particular in the use of multi-context environment.\\

With a number of different implementations of \logic{} and their corresponding languages, attempting to translate one language into another is a natural problem. Logical systems in all of the formalisms are considered to be variants of the same logic, \logic{}, thus we expect them to be equivalent. As programming languages, these systems do differ a little, making translation a less trivial task.

Our new hybrid language, \langHyb{}, is easily embedded in both labeled and label-free implementations (\langL{} and \langLF{}, respectively) -- in both cases the translation preserves types and reductions. To go in the other direction -- that is, from \langL{} to \langHyb{} or from \langLF{} to \langHyb{} -- proved to be a more difficult and technical problem, to which we only provide a partial solution.\\

Finally, one of the most important features of a logical programming language is the termination of its evaluation. In languages with solid theoretical foundations and without general recursion it is often the case that we can prove termination of well-typed programs. Languages based on \logic{} are, in that respect, no different. We show termination of evaluation for variant of \langLF{} without possibility ($<*>$) using standard Tait's method for simply-typed $\lambda$-calculus. We then provide extension of this result to a full \langLF{} language. 

It is worth noting that from the proof of termination formalized in Coq we can extract the evaluator in OCaml programming language. In fact, such evaluator has been extracted for the \langLF{} without possibility.


\subsection{Formalization in Coq}

The logical (and type) systems and all the theorems mentioned throughout this thesis have been formalized in Coq. We have left implementation details out of the main text; all the remarks on Coq development can be found in Appendix \ref{appendix:coq}. One thing to mention is the libraries and $\lambda$-calculus formalization that we chose. We use first-order representation, not higher-order abstract syntax, as $\alpha$-conversion is not done automatically in Coq. We have chosen Chargu√©raud's metatheory package(\cite{charg08}, \cite{charg11}) and an approach known as locally nameless representation. The idea behind it is a combination of de Bruijn indices used for bound variables and fresh, named binders for free variables. To give an example, an identity function in such representation looks like: $\lambda {A} . {\bte 0} $, rather than $\lam v A v$, but expressing a hypothesis that is already in a context does not use indices: $\hyp{\fte v}{}$. 

Another important difference is cofinite quantification~\cite{charg08} when introducing new variables. An example of this approach is the following inference rule:
\begin{center}
\footnotesize
\begin{tabular}{ c }
\inference[]{\forall {v \notin L}, (v:::A) :: \Gamma |- M^v  ::: B} {\Gamma |- \lambda A . M ::: A ---> B}
\end{tabular}\\
\normalsize
\end{center}

$M^v$ is an operation replacing $\bte 0$ with $\fte v$ in term $M$. Note that the premise $ (v::A)::\Gamma |- M ^ v ::: B $ is required to hold for \emph{any} $v$ from outside some given set $L$ -- not necessary the set of free variables used in $M$. We interpret rule $v \notin L$ as freshness and read this condition as "for any $v$ that is fresh enough". We will expand this topic in the Appendix \ref{appendix:coq}.

\section {Plan of the thesis}
In Chapter \ref{chapter:logic} we give formal introduction to modality, intuitionistic modality and -- in particular -- \logic{}. For the latter, we describe axiomatization as well as a number of deduction systems, including the one that was developed as part of this thesis. We also expand the topic of applications of \logic{}, motivating its usage as a type system.\\

In Chapter \ref{chapter:lang} we introduce three languages: \langL{}, \langLF{} and \langHyb{}, corresponding to the three variants of natural deduction system for \logic{} that were presented in Chapter \ref{chapter:logic}. We justify correctness of these languages by presenting proofs of progress and preservation.\\

In Chapter \ref{chapter:relations} we establish relationships between the languages introduced in Chapter \ref{chapter:lang}. This is done via a series of translations $\langL{} <-> \langHyb{} <-> \langLF{}$, all of which preserve type inference.\\

In Chapter \ref{chapter:termin} we discuss termination results  -- first for sublanguage of \langLF{} without $<*>$ type, then for complete \langLF{}, which requires slightly more complicated approach using continuations.\\

Finally, Chapter \ref{chapter:summary} summarizes contributions of this thesis.\\

Orthogonally to the above mentioned chapters, we discuss implementation details in Appendix \ref{appendix:coq}. Its structure corresponds to the structure of chapters, but in there we focus more on the challenges coming from using Coq proof assistant and differences between paper description and actual implementation.
