\documentclass[12pt]{article}
\usepackage{semantic}
\usepackage{amssymb}
\usepackage{setspace}
\usepackage{bussproofs}

\newcommand{\tab}[0]{\;\;\;\;}
\newcommand{\mathinfer}[3]{\inference[$\mathrm{#1}$]{#2}{#3}}
\newtheorem{note}{Note}

\title{Languages details - draft}

\begin{document}
\maketitle

\section{Labeled language}

TODO: short intro + some facts important from implementation perspective (one context etc) + maybe some motivation behind choosing one formalism over others; may be split across subsections

\subsection{Statics}
\subsubsection{Language}
This is a description of actual language, as presented in \cite{murphy04}.

\begin{spacing}{2.5}
\mathinfer{hyp_L}
	{w \in \Omega}
	{\Omega; (x : A @ w) \cup \Gamma \vdash \mathrm{hyp_L} x : A @ w}

\mathinfer{lam_L}
	{\Omega; (x: A @ w) \cup \Gamma \vdash M : A' @ w}
	{\Omega; \Gamma \vdash \lambda_L x, M : A \rightarrow A' @ w}

\mathinfer{appl_L}
	{\Omega; \Gamma \vdash M : A \rightarrow A' @ w \tab
	 \Omega; \Gamma \vdash N : A @ w}
	{\Omega; \Gamma \vdash \mathrm{appl_L}M N : A' @ w}

\mathinfer{box_L}
	{w \in \Omega \tab 
	w' \mathrm{fresh} \tab
	w' \cup \Omega; \Gamma \vdash M : A @ w'}
	{\Omega; \Gamma \vdash \mathrm{box_L} w' . M : \Box A @ w}

\mathinfer{unbox_L}
	{\Omega; \Gamma \vdash M : \Box A @ w}
	{\Omega; \Gamma \vdash \mathrm{unbox_L} M : A @ w }

\mathinfer{here_L}
	{\Omega; \Gamma \vdash M : A @ w}
	{\Omega; \Gamma \vdash \mathrm{here_L} M : \Diamond A @ w}

\mathinfer{letd_L}
	{\Omega; \Gamma \vdash M : \Diamond A @ w \tab
	 w' \mathrm{fresh} \tab
	\cup \Omega; (A, w') \cup \Gamma \vdash N : B @ w}
	{\Omega; \Gamma \vdash \mathrm{letdia_L} x := M \mathrm{in } N : B @ w  }

\mathinfer{fetch_L}
	{w \in \Omega \tab
	 \Omega; \Gamma \vdash M : \Box A @ w'}
	{\Omega; \Gamma \vdash \mathrm{fetch_L} w' M : \Box A @ w'}

\mathinfer{get_L}
	{w \in \Omega \tab
	 \Omega; \Gamma \vdash M : \Diamond A @ w'}
	{\Omega; \Gamma \vdash \mathrm{get_L} w' . M : \Diamond A @ w'}
\end{spacing}

\subsubsection{Implementation}
\begin{note}
This is just current, not final implementation of labeled language. Planned changes include using locally nameless instead of de Bruijn indices for variables and replacing current implementation of $\Omega$ (using fsets from Metatheory library) with one using lists and their permutations.
\\
Both changes are due to compatibility in translation with label-free language.
\end{note}

\begin{spacing}{2.5}
\mathinfer{hyp_L}
	{w \in \Omega \tab \Gamma[n]=(A, w)}
	{\Omega; \Gamma \vdash \mathrm{hyp_L} n : A @ w}

\mathinfer{lam_L}
	{\Omega; (A, w) :: \Gamma \vdash M : A' @ w}
	{\Omega; \Gamma \vdash \lambda_L A, M : A \rightarrow A' @ w}

\mathinfer{appl_L}
	{\Omega; \Gamma \vdash M : A \rightarrow A' @ w \tab
	 \Omega; \Gamma \vdash N : A @ w}
	{\Omega; \Gamma \vdash \mathrm{appl_L}M N : A' @ w}

\mathinfer{box_L}
	{w \in \Omega \tab 
	 \forall_w w  \notin \mathrm{L} \rightarrow w' \cup \Omega; \Gamma \vdash M^{w'} : A @ w'}
	{\Omega; \Gamma \vdash \mathrm{box_L} M : \Box A @ w}

\mathinfer{unbox_L}
	{\Omega; \Gamma \vdash M : \Box A @ w}
	{\Omega; \Gamma \vdash \mathrm{unbox_L} M : A @ w }

\mathinfer{here_L}
	{\Omega; \Gamma \vdash M : A @ w}
	{\Omega; \Gamma \vdash \mathrm{here_L} M : \Diamond A @ w}

\mathinfer{letd_L}
	{w \in \Omega \tab
	 \Omega; \Gamma \vdash M : \Diamond A @ w \tab
	 \forall_{w'} 
		w' \notin \mathrm{L} \rightarrow w' 
		\cup \Omega; (x: A, w') :: \Gamma \vdash N^{w'} : B @ w}
	{\Omega; \Gamma \vdash \mathrm{letdia_L} M \mathrm{in } N : B @ w  }

\mathinfer{fetch_L}
	{w \in \Omega \tab
	 \Omega; \Gamma \vdash M : \Box A @ w'}
	{\Omega; \Gamma \vdash \mathrm{fetch_L} w' M : \Box A @ w'}

\mathinfer{get_L}
	{w \in \Omega \tab
	 \Omega; \Gamma \vdash M : \Diamond A @ w'}
	{\Omega; \Gamma \vdash \mathrm{get_L} w' M : \Diamond A @ w'}
\end{spacing}

\subsection{Dynamics}

\subsubsection{Values}
$$\mathrm{value_L}(\lambda_L A, M)$$
$$\mathrm{value_L}(\mathrm{box_L} M)$$
$$\mathrm{value_L}(M) \rightarrow \mathrm{value_L}(\mathrm{here_L} M)$$

\subsubsection{Reductions}
For reduction steps, we silently use assumption that all terms are locally closed with respect to worlds.
This requirement may later be moved to static semantics, as is is widely used both in definitions and lemmas.\\
We do not list trivial inductive reduction steps here.

$$ \mathrm{appl_L} (\lambda_L A, M) N, w  \mapsto [ N / 0 ] M, w $$
$$ \mathrm{unbox_L} (\mathrm{box_L} M ), w \mapsto M^w, w $$
$$ \mathrm{letd_L} (\mathrm{here_L} M) \mathrm{in} N, w \mapsto [ M / 0 ] N^w, w $$
$$ \mathrm{value_L} M \rightarrow \mathrm{fetch_L} w M, w' \mapsto \{ w' / w \} M, w' $$
$$ \mathrm{value_L} M \rightarrow 
		\mathrm{get_L} w (\mathrm{here_L} M) , w' \mapsto 
		\mathrm{here_L} \{ w' / w \} M, w' $$

\subsection{Substitution}
Since the labeled language has only one context stack, both definition and actual implementation of substitution functions is streight forward. For the sake of completeness, we will provide the definitions.

\subsubsection{"world" substitution}
We use helper function $\mathrm{shift}$, which does the following:
\begin{itemize}
	\item On free world, it is an identity function
	\item On bound world, it increases the binding number by $1$
\end{itemize}

$$ \{ w_1 / w_2 \} (\mathrm{hyp_L} n) \Rightarrow \mathrm{hyp_L} n $$  
$$ \{ w_1 / w_2 \} (\lambda_L A, M) \Rightarrow \lambda_L A, \{w_1 / w_2 \} M $$  
$$ \{ w_1 / w_2 \} (\mathrm{appl_L} M N) \Rightarrow \mathrm{appl_L}  \{w_1 / w_2 \}M \{w_1 / w_2 \} N$$  
$$ \{ w_1 / w_2 \} (\mathrm{box_L} M) \Rightarrow 
			   \mathrm{box_L} \{\mathrm{shift} w_1 / \mathrm{shift} w_2' \} M $$  
$$ \{ w_1 / w_2 \} (\mathrm{unbox_L} M) \Rightarrow \mathrm{unbox_L} \{w_1 / w_2 \} M $$  
$$ \{ w_1 / w_2 \} (\mathrm{here_L} n) \Rightarrow \mathrm{here_L} \{w_1 / w_2 \} M $$  
$$ \{ w_1 / w_2 \} (\mathrm{letd_L} M N) \Rightarrow 
			    \mathrm{letd_L} \{w_1 / w_2 \}M \{\mathrm{shift} w_1 / \mathrm{shift} w_2 \} M$$  
$$ \{ w_1 / w_2 \} (\mathrm{fetch_L} w_2 M) \Rightarrow \mathrm{fetch_L} w_1 \{w_1 / w_2 \} M $$  
$$ \{ w_1 / w_2 \} (\mathrm{fetch_L} w M) \Rightarrow \mathrm{fetch_L} w \{w_1 / w_2 \} M $$  
$$ \{ w_1 / w_2 \} (\mathrm{get_L} w_2 M) \Rightarrow \mathrm{get_L} w_1 \{w_1 / w_2 \} M $$  
$$ \{ w_1 / w_2 \} (\mathrm{get_L} w M) \Rightarrow \mathrm{get_L} w \{w_1 / w_2 \} M $$ 

\subsubsection{"term" substitution}

$$ [ M / n ] \mathrm{hyp_L} n \Rightarrow M $$
$$ [ M / n ] \mathrm{hyp_L} m \Rightarrow \mathrm{hyp_L} m $$
$$ [ M / n ] \lambda_L A, N \Rightarrow \lambda_L A, [M / \mathrm{S } n] N$$
$$ [ M / n ] \mathrm{appl_L} N_1 N_2 \Rightarrow \mathrm{appl_L} [M / n] N_1 [M / n] N_2$$
$$ [ M / n ] \mathrm{box_L} N \Rightarrow \mathrm{box_L} [M / n] N $$
$$ [ M / n ] \mathrm{unbox_L} N \Rightarrow \mathrm{unbox_L} [M / n ]N $$
$$ [ M / n ] \mathrm{here_L} N \Rightarrow \mathrm{here_L} [M / n ]N $$
$$ [ M / n ] \mathrm{letd_L} N_1 \mathrm{in} N_2 \Rightarrow \mathrm{letd_L} [M / n ]N_1 \mathrm{ in } [M/\mathrm{S } n]N_2 $$
$$ [ M / n ] \mathrm{fetch_L} N \Rightarrow \mathrm{fetch_L} [M / n ]N $$
$$ [ M / n ] \mathrm{get_L} N \Rightarrow \mathrm{get_L} [M / n ]N $$

\section{Label-free language}

The original description of logic behind this language is in \cite{galmiche11} and is, indeed, label-free.
The paper does not provide any terms to go with the logic, so we had to add them on out own. We will use the example of $\Box A$ type.\\
$\Box_I$ rule is very streightforward\\

\mathinfer{box_{LF}}
	{ \Gamma; G \vdash \emptyset \vdash M : A}
	{G \vdash \Gamma \vdash \mathrm{box_{LF}}  M : \Box A}

First, we wanted $\Box_E$ rules to be the following:

\mathinfer{unbox_{LF}}
	{G \vdash \Gamma \vdash M : \Box A}
	{G \vdash \Gamma \vdash \mathrm{unbox_{LF}} M : A }

\mathinfer{unbox\_fetch_{LF}}
	{\Gamma; G \vdash \Gamma' \vdash M : \Box A}
	{\Gamma'; G \vdash \Gamma \vdash \mathrm{unbox\_fetch_{LF}} M : A }

So without explicitly stating in the term, what is the context used for $\mathrm{fetch}$ operation. But this causes problems when we start to think of how to define reduction for $\Box$ type. We want to have this proof

\alwaysNoLine
\AxiomC{$\mathcal{D}$}
\UnaryInfC{$G;\Gamma;\Gamma' \vdash \emptyset \vdash M : A$}
\alwaysSingleLine
\UnaryInfC{$G; \Gamma \vdash \Gamma' \vdash \mathrm{box} M : \Box A$}
\UnaryInfC{$G; \Gamma' \vdash \Gamma \vdash \mathrm{unbox\_fetch} (\mathrm{box} M) : A$}
\DisplayProof

reduced to 

\alwaysNoLine
\AxiomC{$\mathcal{D}$}
\UnaryInfC{$G; \Gamma' \vdash \Gamma \vdash M : A$}
\DisplayProof

with some modifications on $\mathcal{D}$ and $M$ - namely, e.g. whenever we see $\mathrm{unbox_fetch}$ within $M$, we have to figure out whether we are exchanging the current context for $\Gamma$ - if so, we should use $\mathrm{unbox}$ instead.\\

Of course this approach would require looking at entire judgements, not just terms, in order to make the change - since we do not know, what context will be switched by $\mathrm{unbox_fetch}$.\\

One solution would be to try and unify $\mathrm{unbox\_fetch}$ with $\mathrm{unbox}$ terms by stating:\\
\mathinfer{unbox_{LF}}
	{G \vdash \Gamma \vdash M : \Box A}
	{G \vdash \Gamma \vdash \mathrm{unbox\_fetch{LF}} M : A }
but this would be incorrect, since then we add disambiguity to the typing system.\\

Let us then try to add context to the term when we are switching it. The rule for fetch would change to the following:\\

\mathinfer{unbox\_fetch_{LF}}
	{\Gamma; G \vdash \Gamma' \vdash M : \Box A}
	{\Gamma'; G \vdash \Gamma \vdash \mathrm{unbox\_fetch_{LF}} \Gamma' M : A }

This allows us to easily make modifications on $M$, but brings our attention to a different problem. What if two identical contexts $\Gamma$ exist in the system, one being the 'close' context and the other the 'background' one, $ G; \Gamma \vdash \Gamma \vdash M : A$?\\
Then we can no longer be sure that our modified $M$ is correctly transformed, since we cannot distinguish between two contexts, one being in the background and the other in the front.\\

It seems that the only solution is to avoid such situation - ensure that contexts are easily distinguishable. One obvious way is to  state that each variable name occurs only once in all the contexts. It solves almost all of the problems - except for the case of empty contexts. To distinguish between those, we do in fact need to explicitly name each context with a unique name.\\

In other applications we may consider undistinguishable empty contexts, but since we do intend to create a language equivalent to labeled IS5, here we have to tell them apart.

\subsection{Statics}

\subsubsection{Language}
\begin{spacing}{2.5}
\mathinfer{hyp_{LF}}
	{}
	{G \vdash w, (x : A) \cup \Gamma \vdash \mathrm{hyp_{LF}} x : A}

\mathinfer{lam_{LF}}
	{G \vdash w, (x: A) \cup \Gamma \vdash M : A'}
	{G \vdash w, \Gamma \vdash \lambda_{LF} x, M : A \rightarrow A'}

\mathinfer{appl_{LF}}
	{G \vdash w, \Gamma \vdash M : A \rightarrow A' \tab
	 G \vdash w, \Gamma \vdash N : A}
	{G \vdash w, \Gamma \vdash \mathrm{appl_{LF}}M N : A'}

\mathinfer{box_{LF}}
	{w' \mathrm{fresh} \tab
	 (w, \Gamma) \cup G \vdash w', \emptyset \vdash M : A}
	{G \vdash w, \Gamma \vdash \mathrm{box_{LF}}  M : \Box A}

\mathinfer{unbox_{LF}}
	{G \vdash w, \Gamma \vdash M : \Box A}
	{G \vdash w, \Gamma \vdash \mathrm{unbox_{LF}} M : A }

\mathinfer{unbox\_fetch_{LF}}
	{(w, \Gamma)  \cup G \vdash w', \Gamma' \vdash M : \Box A}
	{(w', \Gamma') \cup G \vdash w, \Gamma \vdash \mathrm{unbox\_fetch_{LF}} w' M : A }

\mathinfer{here_{LF}}
	{G \vdash w, \Gamma \vdash M : A}
	{G \vdash w, \Gamma \vdash \mathrm{here_{LF}} M : \Diamond A}

\mathinfer{get\_here_{LF}}
	{(w, \Gamma) \cup G \vdash w', \Gamma' \vdash M : \Diamond A}
	{(w', \Gamma') \cup G \vdash w, \Gamma \vdash \mathrm{get\_here_{LF}} w' . M : \Diamond A}

\mathinfer{letdia_{LF}}
	{G \vdash w, \Gamma \vdash M : \Diamond A \tab
	 w' \mathrm{fresh} \tab
	(x: A, w') \cup G \vdash w, \Gamma \vdash N : B}
	{G \vdash w, \Gamma \vdash \mathrm{letdia_{LF}} x := M \mathrm{in } N : B }

\mathinfer{letdia\_get_{LF}}
	{(w, \Gamma) \cup G \vdash w', \Gamma' \vdash M : \Diamond A \tab
	 w' \mathrm{fresh} \tab
	(x: A, w') \cup G \vdash w, \Gamma \vdash N : B}
	{(w', \Gamma') \cup G \vdash w, \Gamma \vdash \mathrm{letdia\_get_{LF}} x := M \mathrm{in } N : B }
\end{spacing}

\subsection{Implementation}

*implementation details to come as they will be finalized in the development

\subsection{Dynamics}

* with trees :) and justification

\subsection{Substitution}

\section{Translation}

\section{Normalization properties}

\begin{thebibliography}{9}
\bibitem{murphy04}
 	Tom Murphy VII, Karl Crary, Robert Harper, Frank Pfenning
	A Symetric Modal Lambda calculus for Distributed Computing

\bibitem{galmiche11}
	Didier Galmiche, Yakoub Salhi
	Label-free Proof Systems for Intuitionistic Modal Logic IS5
\end{thebibliography}

\end{document}            
